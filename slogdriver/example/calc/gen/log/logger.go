// Code generated by goa v3.12.4, DO NOT EDIT.
//
// slogdriver logger implementation
//
// Command:
// $ goa gen calc/design

package log

import (
	"context"
	"fmt"
	"log/slog"
	"net/http"
	"os"
	"time"

	"github.com/kitagry/slogdriver"
	httpmdlwr "goa.design/goa/v3/http/middleware"
	"goa.design/goa/v3/middleware"
)

// Logger is an adapted slogdriver logger
type Logger struct {
	*slog.Logger
}

// New creates a new slogdriver logger
func New(opts slogdriver.HandlerOptions) *Logger {
	logger := slogdriver.New(os.Stdout, opts)
	return &Logger{logger}
}

// Log is called by the log middleware to log HTTP requests key values
func (logger *Logger) Log(keyvals ...any) error {
	logger.Logger.Info("HTTP Request", keyvals...)
	return nil
}

// Print is called by the log middleware
func (logger *Logger) Print(v ...any) {
	logger.Logger.Info(fmt.Sprint(v...))
}

// Printf is called by the log middleware
func (logger *Logger) Printf(msg string, args ...any) {
	logger.Logger.Info(fmt.Sprintf(msg, args...))
}

// Println is called by the log middleware
func (logger *Logger) Println(v ...any) {
	logger.Logger.Info(fmt.Sprint(v...))
}

// Fatal is called by the log middleware
func (logger *Logger) Fatal(v ...any) {
	logger.Logger.Log(context.Background(), slogdriver.LevelCritical, fmt.Sprint(v...))
	os.Exit(1)
}

// Fatalf is called by the log middleware
func (logger *Logger) Fatalf(msg string, args ...any) {
	logger.Logger.Log(context.Background(), slogdriver.LevelCritical, fmt.Sprintf(msg, args...))
	os.Exit(1)
}

// Fatalln is called by the log middleware
func (logger *Logger) Fataln(v ...any) {
	logger.Logger.Log(context.Background(), slogdriver.LevelCritical, fmt.Sprint(v...))
	os.Exit(1)
}

// FormatFields formats input keyvals
// ref: https://github.com/goadesign/goa/blob/v1/logging/logrus/adapter.go#L64
func FormatFields(keyvals []any) map[string]any {
	n := (len(keyvals) + 1) / 2
	res := make(map[string]any, n)
	for i := 0; i < len(keyvals); i += 2 {
		k := keyvals[i]
		var v any
		if i+1 < len(keyvals) {
			v = keyvals[i+1]
		}
		res[fmt.Sprintf("%v", k)] = v
	}
	return res
}

// SlogdriverHttpMiddleware extracts and formats http request and response information into
// GCP Cloud Logging optimized format.
// If logger is not *Logger, it returns goa default middleware.
// healthCheckPaths is used to skip log when the request is correct.
func SlogdriverHttpMiddleware(logger middleware.Logger, healthCheckPaths []string) func(h http.Handler) http.Handler {
	switch logr := logger.(type) {
	case *Logger:
		return slogdriverHttpMiddleware(logr, healthCheckPaths)
	default:
		return httpmdlwr.Log(logger)
	}
}

func slogdriverHttpMiddleware(logger *Logger, healthCheckPaths []string) func(h http.Handler) http.Handler {
	return func(h http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			start := time.Now()

			rw := httpmdlwr.CaptureResponse(w)
			h.ServeHTTP(rw, r)

			var res http.Response
			res.StatusCode = rw.StatusCode
			res.ContentLength = int64(rw.ContentLength)

			p := slogdriver.MakeHTTPPayload(r, &res)
			p.Latency = time.Since(start).String()

			var level slog.Level
			switch {
			case rw.StatusCode < 400:
				level = slogdriver.LevelInfo
			case rw.StatusCode < 500:
				level = slogdriver.LevelWarning
			default:
				level = slogdriver.LevelError
			}

			if isHealthCheckPath(r.URL.Path, healthCheckPaths) && rw.StatusCode < 400 {
				return
			}

			logger.Logger.Log(r.Context(), level, "request finished", slogdriver.HTTPKey, p)
		})
	}
}

func isHealthCheckPath(path string, healthCheckPaths []string) bool {
	for _, hp := range healthCheckPaths {
		if path == hp {
			return true
		}
	}
	return false
}
